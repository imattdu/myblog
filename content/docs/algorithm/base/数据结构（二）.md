+++

title = "数据结构（二）"
date = 2022-01-01T00:52:25+08:00
featured = true
comment = true
toc = true
reward = true
pinned = true
weight = 2
categories = [
  "算法基础"
]
tags = [
]
series = [
]

+++

本文将介绍常用数据结构

<!--more-->



## 开始



### 字典树







```cpp
//
// Created by matt on 2022/1/2.
// input
/*
5
I abc
Q abc
Q ab
I ab
Q ab
 * */
#include <iostream>
#include <cstdio>

using namespace std;

const int N = 1e5 + 10;
int son[N][26], cnt[N], idx;
char str[N];

void insert(char str[]) {

    int p = 0;
    for (int i = 0; str[i]; i++) {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] += ++idx;
        p = son[p][u];
        // cout << p << ':' << son[p][u] << endl;
    }
    cnt[p]++;
}

int query(char str[]) {
    int p = 0;
    for (int i = 0; str[i]; i++) {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}

int main(){
    int n;
    scanf("%d", &n);
    char ch;

    while (n--) {

        cin >> ch >> str;
        if (ch == 'I') insert(str);
        else cout << query(str) << endl;
    }

}
```









### 并查集

合并俩个集合

判断俩个元素是否在一个集合中



![](https://raw.githubusercontent.com/imattdu/img/main/img/2022/01/02/20220102235623.png)





可能读取空格

```cpp
scanf("%c", &ch)
char str[2];    
// good
scanf("%s", s);   
```





[333](/zh-cn/blogs/位运算)







小根堆：小于子节点

x l:2x r:2x+1





0 0

所以下标从1开始







o(n)











## 堆排序



### 基础堆排序



输入一个长度为 nn 的整数数列，从小到大输出前 mm 小的数。

#### 输入格式

第一行包含整数 nn 和 mm。

第二行包含 nn 个整数，表示整数数列。

#### 输出格式

共一行，包含 mm 个整数，表示整数数列中前 mm 小的数。

#### 数据范围

1≤m≤n≤1051≤m≤n≤105，
1≤数列中元素≤1091≤数列中元素≤109

#### 输入样例：

```
5 3
4 5 1 3 2
```

#### 输出样例：

```
1 2 3
```







```cpp
//
// Created by matt on 2022/1/3.
//
#include <iostream>
#include <cstdio>

using namespace std;

const int N = 1e6 + 10;
int h[N], cnt;
int n, m;

void up(int u) {
    if (u / 2 && h[u / 2] > h[2]) {
        swap(h[u / 2], h[u]);
        up(u >> 1);
    }
}

void down(int u) {
    int t = u;
    if (2 * u <= cnt && h[2 * u] < h[t]) t = 2 * u;
    if (2 * u + 1 <= cnt && h[2 * u + 1] < h[t]) t = 2 * u + 1;
    if (u != t) {
        swap(h[u], h[t]);
        down(t);
    }
}

//

int main() {
    scanf("%d %d", &n, &m);
    cnt = n;
    for (int i = 1; i <= n; i++) scanf("%d", &h[i]);
    for (int i = n / 2; i; i--) down(i);
    while (m--) {
        printf("%d ", h[1]);
        h[1] = h[cnt--];
        down(1);
    }
    puts("");
    return 0;
}
```



### 模拟堆



维护一个集合，初始时集合为空，支持如下几种操作：

1. `I x`，插入一个数 xx；
2. `PM`，输出当前集合中的最小值；
3. `DM`，删除当前集合中的最小值（数据保证此时的最小值唯一）；
4. `D k`，删除第 kk 个插入的数；
5. `C k x`，修改第 kk 个插入的数，将其变为 xx；

现在要进行 NN 次操作，对于所有第 22 个操作，输出当前集合的最小值。

#### 输入格式

第一行包含整数 NN。

接下来 NN 行，每行包含一个操作指令，操作指令为 `I x`，`PM`，`DM`，`D k` 或 `C k x` 中的一种。

#### 输出格式

对于每个输出指令 `PM`，输出一个结果，表示当前集合中的最小值。

每个结果占一行。

#### 数据范围

1≤N≤1051≤N≤105
−109≤x≤109−109≤x≤109
数据保证合法。

#### 输入样例：

```
8
I -10
PM
I -10
D 1
C 2 8
I 6
PM
DM
```

#### 输出样例：

```
-10
6
```



#### **出错**

在进行节点删除的时候，已经heap_sort 然后又交换所以导致错误

```cpp
//
// Created by matt on 2022/1/3.
//
#include <iostream>
#include <cstdio>

using namespace std;

const int N  = 1e5 + 10;
int h[N], ph[N], hp[N], cnt;

void heap_swap(int a, int b) {
    swap(ph[hp[a]], ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void up(int u) {
    if (u / 2 && h[u / 2] > h[u]) {
        heap_swap(u, u / 2);
        up(u >> 1);
    }
}

void down(int u) {
    int t = u;
    if (2 * u <= cnt && h[2 * u] < h[t]) t = 2 * u;
    if (2 * u + 1 <= cnt && h[2 * u + 1] < h[t]) t = 2 * u + 1;
    if (u != t) {
        heap_swap(u, t);
        down(t);
    }
}



int main() {
    int n, m = 0;
    scanf("%d", &n);
    string op;
    int k, x;
    while (n--) {
        cin >> op;
        if (op == "I") {
            cin >> x;
            m++;
            h[++cnt] = x;
            ph[m] = cnt;
            hp[cnt] = m;
            up(cnt);
        } else if (op == "PM") printf("%d\n", h[1]);
        else if (op == "DM") {
            heap_swap(1, cnt);
            //h[1] = h[cnt--];
            cnt--;
            down(1);
        } else if (op == "D") {
            scanf("%d", &k);
            int u = ph[k];
            heap_swap(ph[k], cnt);
            // h[ph[k]] = h[cnt--];
            cnt--;
            down(u);
            up(u);
        } else if (op == "C") {
            scanf("%d %d" , &k, &x);
            h[ph[k]] = x;
            down(ph[k]);
            up(ph[k]);
        }
    }

    return 0;
}

```



